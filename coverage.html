
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>deplist: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/RedHatProductSecurity/deplist/cmd/deplist/deplist.go (0.0%)</option>
				
				<option value="file1">github.com/RedHatProductSecurity/deplist/dependencies.go (87.5%)</option>
				
				<option value="file2">github.com/RedHatProductSecurity/deplist/deplist.go (71.9%)</option>
				
				<option value="file3">github.com/RedHatProductSecurity/deplist/internal/scan/glide.go (0.0%)</option>
				
				<option value="file4">github.com/RedHatProductSecurity/deplist/internal/scan/golang.go (0.0%)</option>
				
				<option value="file5">github.com/RedHatProductSecurity/deplist/internal/scan/gopkg.go (0.0%)</option>
				
				<option value="file6">github.com/RedHatProductSecurity/deplist/internal/scan/jar.go (0.0%)</option>
				
				<option value="file7">github.com/RedHatProductSecurity/deplist/internal/scan/maven.go (0.0%)</option>
				
				<option value="file8">github.com/RedHatProductSecurity/deplist/internal/scan/nodejs.go (0.0%)</option>
				
				<option value="file9">github.com/RedHatProductSecurity/deplist/internal/scan/python.go (0.0%)</option>
				
				<option value="file10">github.com/RedHatProductSecurity/deplist/internal/scan/ruby.go (55.2%)</option>
				
				<option value="file11">github.com/RedHatProductSecurity/deplist/internal/scan/rust.go (0.0%)</option>
				
				<option value="file12">github.com/RedHatProductSecurity/deplist/internal/utils/utils.go (25.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "strings"

        "github.com/RedHatProductSecurity/deplist"
        purl "github.com/mcoops/packageurl-go"
        log "github.com/sirupsen/logrus"
)

func main() <span class="cov0" title="0">{
        deptypePtr := flag.Int("deptype", -1, "golang, nodejs, python etc")
        debugPtr := flag.Bool("debug", false, "debug logging (default false)")
        ignorePtr := flag.String("ignore", "", "comma separated list of directory names to ignore (default '')")

        flag.Parse()

        if *debugPtr == true </span><span class="cov0" title="0">{
                log.SetLevel(log.DebugLevel)
        }</span>

        <span class="cov0" title="0">var ignoreDirs []string
        if ignorePtr != nil </span><span class="cov0" title="0">{
                ignoreDirs = strings.Split(*ignorePtr, ",")
        }</span>

        <span class="cov0" title="0">if flag.Args() == nil || len(flag.Args()) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No path to scan was specified, i.e. deplist /tmp/files/")
                return
        }</span>

        <span class="cov0" title="0">path := flag.Args()[0]

        deps, _, err := deplist.GetDeps(path, ignoreDirs...)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span>

        <span class="cov0" title="0">if *deptypePtr == -1 </span><span class="cov0" title="0">{
                for _, dep := range deps </span><span class="cov0" title="0">{
                        inst, _ := purl.FromString(dep.ToString())
                        fmt.Println(inst)
                }</span>
        } else<span class="cov0" title="0"> {
                deptype := deplist.Bitmask(*deptypePtr)
                for _, dep := range deps </span><span class="cov0" title="0">{
                        if (dep.DepType &amp; deptype) == deptype </span><span class="cov0" title="0">{
                                fmt.Printf("%s@%s\n", dep.Path, dep.Version)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package deplist

import (
        "fmt"
)

// Bitmask type allows easy tagging of what langs there are
type Bitmask uint32

// Dependency per dependency info
type Dependency struct {
        DepType Bitmask  // golang, nodejs, python etc
        Path    string   // the module path, github.com/teris-io/shortid
        Version string   // v0.0.0-20171029131806-771a37caa5cf
        Files   []string // if available, list of all files for a package
}

// DepFoundAddFlag add a lang type to the bitmask
func (f *Bitmask) DepFoundAddFlag(flag Bitmask) <span class="cov8" title="1">{ *f |= flag }</span>

// DepFoundHasFlag deteremine if bitmask has a lang type
func (f Bitmask) DepFoundHasFlag(flag Bitmask) bool <span class="cov0" title="0">{ return f&amp;flag != 0 }</span>

func (d *Dependency) ToString() string <span class="cov8" title="1">{
        return fmt.Sprintf("pkg:%s/%s@%s", GetLanguageStr(d.DepType), d.Path, d.Version)
}</span>

// GetLanguageStr returns from a bitmask return the ecosystem name
func GetLanguageStr(bm Bitmask) string <span class="cov8" title="1">{
        if bm&amp;LangGolang != 0 </span><span class="cov8" title="1">{
                return "golang"
        }</span> else<span class="cov8" title="1"> if bm&amp;LangJava != 0 </span><span class="cov8" title="1">{
                return "maven"
        }</span> else<span class="cov8" title="1"> if bm&amp;LangNodeJS != 0 </span><span class="cov8" title="1">{
                return "npm"
        }</span> else<span class="cov8" title="1"> if bm&amp;LangPython != 0 </span><span class="cov8" title="1">{
                return "pypi"
        }</span> else<span class="cov8" title="1"> if bm&amp;LangRuby != 0 </span><span class="cov8" title="1">{
                return "gem"
        }</span> else<span class="cov8" title="1"> if bm&amp;LangRust != 0 </span><span class="cov8" title="1">{
                return "cargo"
        }</span>
        <span class="cov0" title="0">return "generic"</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package deplist

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "slices"
        "strings"

        "github.com/RedHatProductSecurity/deplist/internal/scan"
        "github.com/RedHatProductSecurity/deplist/internal/utils"

        log "github.com/sirupsen/logrus"
)

// enums start at 1 to allow us to specify found languages 0 = nil
const (
        LangGeneric = 0
        LangGolang  = 1 &lt;&lt; iota
        LangJava
        LangNodeJS
        LangPython
        LangRuby
        LangRust
)

func init() <span class="cov8" title="1">{
        // check for the library required binaries
        languages := map[string]string{
                "yarn":   "yarn",
                "npm":    "npm",
                "go":     "go",
                "bundle": "bundler gem",
        }

        for lang_bin, lang_name := range languages </span><span class="cov8" title="1">{
                if _, err := exec.LookPath(lang_bin); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(lang_name, " is required in PATH")
                }</span>
        }
        <span class="cov8" title="1">log.SetLevel(log.WarnLevel)</span>
}

type Discovered struct {
        deps       []Dependency
        foundTypes Bitmask
}

func addPackagesToDeps(discovered Discovered, pkgs map[string]string, lang Bitmask) Discovered <span class="cov8" title="1">{
        if len(pkgs) &gt; 0 </span><span class="cov8" title="1">{
                discovered.foundTypes.DepFoundAddFlag(lang)
        }</span>

        <span class="cov8" title="1">for name, version := range pkgs </span><span class="cov8" title="1">{
                discovered.deps = append(discovered.deps,
                        Dependency{
                                DepType: lang,
                                Path:    strings.TrimSuffix(name, "\n"),
                                Version: strings.Replace(version, "v", "", 1),
                                Files:   []string{},
                        })
        }</span>
        <span class="cov8" title="1">return discovered</span>
}

var defaultIgnore []string = []string{
        "docs",
        "example",
        "examples",
        "node_modules",
        "scripts",
        "test",
        "test_scripts",
        "testing",
        "tests",
        "vendor",
        ".git",
}

func getDeps(fullPath string, ignoreDirs []string) ([]Dependency, Bitmask, error) <span class="cov8" title="1">{
        var discovered Discovered
        // special var so we don't double handle both repos with both
        // a Gemfile and Gemfile.lock
        var seenGemfile string

        if _, err := os.Stat(fullPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, 0, os.ErrNotExist
        }</span>

        <span class="cov8" title="1">pomPath := filepath.Join(fullPath, "pom.xml")
        // goPath := filepath.Join(fullPath, "go.mod")
        goPkgPath := filepath.Join(fullPath, "Gopkg.lock")
        glidePath := filepath.Join(fullPath, "glide.lock")
        rubyPath := filepath.Join(fullPath, "Gemfile") // Later we translate Gemfile.lock -&gt; Gemfile to handle both cases
        pythonPath := filepath.Join(fullPath, "requirements.txt")

        ignoreDirs = append(ignoreDirs, defaultIgnore...)
        log.Debugf("directories ignored: %s", ignoreDirs)

        // point at the parent repo, but can't assume where the indicators will be
        err := filepath.Walk(fullPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        // prevent panic by handling failure https://golang.org/pkg/path/filepath/#Walk
                        return err
                }</span>

                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        // prevent walking down the vendors, docs, etc
                        if slices.Contains(ignoreDirs, info.Name()) </span><span class="cov8" title="1">{
                                log.Debugf("Skipping '%s', directory  name '%s' in ignore list", path, info.Name())
                                return filepath.SkipDir
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Two checks, one for filenames and the second switch for full
                        // paths. Useful if we're looking for top of repo

                        // comparisons here are made against the filename only, not full path
                        // so matches will be found at any level of the file tree, not just top-level
                        filename := info.Name()
                        switch filename </span>{
                        case "go.mod":<span class="cov8" title="1">
                                pkgs, err := scan.GetGolangDeps(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">if len(pkgs) &gt; 0 </span><span class="cov8" title="1">{
                                        discovered.foundTypes.DepFoundAddFlag(LangGolang)
                                }</span>

                                <span class="cov8" title="1">for path, goPkg := range pkgs </span><span class="cov8" title="1">{
                                        d := Dependency{
                                                DepType: LangGolang,
                                                Path:    path,
                                                Files:   goPkg.Gofiles,
                                                Version: goPkg.Version,
                                        }
                                        discovered.deps = append(discovered.deps, d)
                                }</span>
                        case "package-lock.json":<span class="cov8" title="1">
                                // if theres not a yarn.lock fall thru
                                if _, err := os.Stat(
                                        filepath.Join(
                                                filepath.Dir(path),
                                                "yarn.lock")); err == nil </span><span class="cov8" title="1">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">fallthrough</span>

                        case "yarn.lock":<span class="cov8" title="1">
                                pkgs, err := scan.GetNodeJSDeps(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        // ignore error
                                        log.Debugf("failed to scan for nodejs: %s", path)
                                        return nil
                                }</span>

                                <span class="cov8" title="1">if len(pkgs) &gt; 0 </span><span class="cov8" title="1">{
                                        discovered.foundTypes.DepFoundAddFlag(LangNodeJS)
                                }</span>

                                <span class="cov8" title="1">for _, p := range pkgs </span><span class="cov8" title="1">{
                                        discovered.deps = append(discovered.deps,
                                                Dependency{
                                                        DepType: LangNodeJS,
                                                        Path:    p.Name,
                                                        Version: p.Version,
                                                        Files:   []string{},
                                                })
                                }</span>
                        case "Cargo.lock":<span class="cov8" title="1">
                                pkgs, err := scan.GetCrates(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        // ignore error
                                        log.Debugf("failed to scan rust crates: %s", path)
                                        return nil
                                }</span>

                                <span class="cov8" title="1">discovered = addPackagesToDeps(discovered, pkgs, LangRust)</span>
                        default:<span class="cov8" title="1">
                                ext := filepath.Ext(filename)
                                // java
                                switch ext </span>{
                                case ".zip":<span class="cov0" title="0">
                                        // be more aggressive with zip files, must contain something java ish
                                        if ok, _ := utils.ZipContainsJava(path); !ok </span><span class="cov0" title="0">{
                                                return nil
                                        }</span>
                                        <span class="cov0" title="0">fallthrough</span>
                                case ".jar":<span class="cov0" title="0">
                                        fallthrough</span>
                                case ".war":<span class="cov0" title="0">
                                        fallthrough</span>
                                case ".ear":<span class="cov0" title="0">
                                        fallthrough</span>
                                case ".adm":<span class="cov0" title="0">
                                        fallthrough</span>
                                case ".hpi":<span class="cov0" title="0">
                                        file := strings.Replace(filepath.Base(path), ext, "", 1) // get filename, check if we can ignore
                                        if strings.HasSuffix(file, "-sources") || strings.HasSuffix(file, "-javadoc") </span><span class="cov0" title="0">{
                                                return nil
                                        }</span>

                                        <span class="cov0" title="0">pkgs, err := scan.GetJarDeps(path)
                                        if err == nil </span><span class="cov0" title="0">{

                                                if len(pkgs) &gt; 0 </span><span class="cov0" title="0">{
                                                        discovered.foundTypes.DepFoundAddFlag(LangJava)
                                                }</span>

                                                <span class="cov0" title="0">for name, version := range pkgs </span><span class="cov0" title="0">{
                                                        // just in case we report the full path to the dep
                                                        name = strings.Replace(name, fullPath, "", 1)

                                                        // if the dep ends with -javadoc or -sources, not really interested
                                                        if !strings.HasSuffix(version, "-javadoc") &amp;&amp; !strings.HasSuffix(version, "-sources") </span><span class="cov0" title="0">{
                                                                discovered.deps = append(discovered.deps,
                                                                        Dependency{
                                                                                DepType: LangJava,
                                                                                Path:    name,
                                                                                Version: version,
                                                                                Files:   []string{},
                                                                        })
                                                        }</span>
                                                }
                                        }
                                }
                        }

                        // translate Gemfile.lock -&gt; Gemfile, to handle either case
                        // but also avoid double-handling, i.e. scanning once for each file
                        <span class="cov8" title="1">path = strings.Replace(path, "Gemfile.lock", "Gemfile", 1)

                        // comparisons here are against the full filepath, so will not match if
                        // these filenames are found in subdirectories, only the top level
                        switch path </span>{
                        case goPkgPath:<span class="cov8" title="1">
                                pkgs, err := scan.GetGoPkgDeps(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">if len(pkgs) &gt; 0 </span><span class="cov8" title="1">{
                                        discovered.foundTypes.DepFoundAddFlag(LangGolang)
                                }</span>
                                <span class="cov8" title="1">for _, goPkg := range pkgs </span><span class="cov8" title="1">{
                                        d := Dependency{
                                                DepType: LangGolang,
                                                Path:    goPkg.Name,
                                                Version: goPkg.Version,
                                        }
                                        discovered.deps = append(discovered.deps, d)
                                }</span>
                        case glidePath:<span class="cov8" title="1">
                                pkgs, err := scan.GetGlideDeps(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">if len(pkgs) &gt; 0 </span><span class="cov8" title="1">{
                                        discovered.foundTypes.DepFoundAddFlag(LangGolang)
                                }</span>
                                <span class="cov8" title="1">for _, goPkg := range pkgs </span><span class="cov8" title="1">{
                                        d := Dependency{
                                                DepType: LangGolang,
                                                Path:    goPkg.Name,
                                                Version: goPkg.Version,
                                        }
                                        discovered.deps = append(discovered.deps, d)
                                }</span>
                        case pomPath:<span class="cov8" title="1">
                                pkgs, err := scan.GetMvnDeps(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">discovered = addPackagesToDeps(discovered, pkgs, LangJava)</span>
                        case rubyPath:<span class="cov8" title="1">
                                // To prevent double handling of both Gemfile and Gemfile.lock
                                // Earier we translate Gemfile.lock -&gt; Gemfile
                                if path == seenGemfile </span><span class="cov8" title="1">{
                                        break</span>
                                }

                                <span class="cov8" title="1">pkgs, err := scan.GetRubyDeps(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">discovered = addPackagesToDeps(discovered, pkgs, LangRuby)
                                seenGemfile = path</span>
                        case pythonPath:<span class="cov8" title="1">
                                pkgs, err := scan.GetPythonDeps(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">discovered = addPackagesToDeps(discovered, pkgs, LangPython)</span>
                        }

                }
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err // should't matter
        }</span>

        <span class="cov8" title="1">return discovered.deps, discovered.foundTypes, nil</span>
}

// findBaseDir walks a directory tree through empty subdirs til it finds a directory with content
func findBaseDir(fullPath string) (string, error) <span class="cov8" title="1">{
        log.Debugf("Checking %s", fullPath)
        files, err := os.ReadDir(fullPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Could not read: %s", err)
        }</span>
        <span class="cov8" title="1">if len(files) == 1 &amp;&amp; files[0].IsDir() </span><span class="cov8" title="1">{
                return findBaseDir(filepath.Join(fullPath, files[0].Name()))
        }</span>
        <span class="cov8" title="1">return fullPath, nil</span>
}

// GetDeps scans a given repository and returns all dependencies found in a DependencyList struct.
func GetDeps(fullPath string, ignoreDirs ...string) ([]Dependency, Bitmask, error) <span class="cov8" title="1">{
        fullPath, err := findBaseDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">deps, foundTypes, err := getDeps(fullPath, ignoreDirs)
        if err != nil </span><span class="cov0" title="0">{
                return deps, foundTypes, err
        }</span>
        // if no deps found, check one level lower in 'src' directory
        // but ignore any new errors
        <span class="cov8" title="1">if len(deps) == 0 </span><span class="cov0" title="0">{
                fullPath = filepath.Join(fullPath, "src")
                if _, err := os.Stat(fullPath); err != nil </span><span class="cov0" title="0">{
                        log.Debugf("No deps found, trying %s", fullPath)
                        deps, foundTypes, _ = getDeps(fullPath, ignoreDirs)
                }</span>
        }

        // de-duplicate
        <span class="cov8" title="1">unique := removeDuplicates(deps)

        return unique, foundTypes, err</span>
}

func removeDuplicates(deps []Dependency) []Dependency <span class="cov8" title="1">{
        seen := map[string]bool{}
        filtered := []Dependency{}
        for _, dep := range deps </span><span class="cov8" title="1">{
                key := dep.ToString()
                if _, ok := seen[key]; !ok </span><span class="cov8" title="1">{
                        seen[key] = true
                        filtered = append(filtered, dep)
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package scan

import (
        "io/ioutil"
        "path/filepath"

        log "github.com/sirupsen/logrus"
        "gopkg.in/yaml.v3"
)

type GlideDeps struct {
        Name    string
        Version string
}

type glideDep struct {
        Name        string   `yaml:"name"`
        Version     string   `yaml:"version"`
        Subpackages []string `yaml:"subpackages"`
}

type glideDeps struct {
        Imports []glideDep
}

func GetGlideDeps(path string) ([]GlideDeps, error) <span class="cov0" title="0">{
        log.Debugf("GetGlideDeps %s", path)

        var deps glideDeps
        var gathered []GlideDeps

        yaml_file, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = yaml.Unmarshal(yaml_file, &amp;deps)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, d := range deps.Imports </span><span class="cov0" title="0">{
                gathered = append(gathered,
                        GlideDeps{
                                Name:    d.Name,
                                Version: d.Version,
                        },
                )

                for _, subpackage := range d.Subpackages </span><span class="cov0" title="0">{
                        gathered = append(gathered,
                                GlideDeps{
                                        Name:    filepath.Join(d.Name, subpackage),
                                        Version: d.Version,
                                },
                        )
                }</span>
        }

        <span class="cov0" title="0">return gathered, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package scan

import (
        "context"
        "encoding/json"
        "errors"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
        "golang.org/x/mod/semver"
)

// GoListDeps holds the import path, version and gofiles for a given go
// dependency
type GoListDeps struct {
        ImportPath string `json:"ImportPath"`
        Module     struct {
                Version string `json:"Version"`
                Replace struct {
                        Version string `json:"Version"`
                } `json:"Replace"`
        } `json:"Module"`
        GoFiles []string `json:"GoFiles"`
}

// GoPkg holds the version and go paths/files for a given dep
type GoPkg struct {
        Version string
        Gofiles []string
}

func getVersion(deps GoListDeps) string <span class="cov0" title="0">{
        /* if replace is specified, then use that version
        * not seen when version and replace.version are different
        * but just in case
         */
        if deps.Module.Replace.Version != "" </span><span class="cov0" title="0">{
                // due to the way we're loading the json this time, this just works
                return deps.Module.Replace.Version
        }</span>
        <span class="cov0" title="0">return deps.Module.Version</span>
}

func runCmd(path string, extraFlag string) ([]byte, error) <span class="cov0" title="0">{
        // go list -f '{{if not .Standard}}{{.Module}}{{end}}' -json -deps ./...
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        // go list -f '{{if not .Standard}}{{.Module}}{{end}}' -json -deps ./...
        var cmd *exec.Cmd

        if extraFlag == "" </span><span class="cov0" title="0">{
                cmd = exec.CommandContext(ctx, "go", "list", "-json", "-deps", "./...")
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.CommandContext(ctx, "go", "list", extraFlag, "-json", "-deps", "./...")
        }</span>

        <span class="cov0" title="0">cmd.Dir = filepath.Dir(path) // // force directory
        out, err := cmd.Output()

        if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                return nil, ctx.Err()
        }</span>

        // mod=vendor sometimes still returns results but returns an error. In
        // that case ignore the error and return what we can
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Debug(string(err.(*exec.ExitError).Stderr))
                if extraFlag == "" </span><span class="cov0" title="0">{
                        // assume some retrival error, we have to redo the cmd with mod=vendor
                        return nil, err
                }</span>

                <span class="cov0" title="0">if len(out) == 0 </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return out, nil</span>
}

/*
* Need to support re-running the go list with and without -mod=vendor
* First run defaults to without, if any kind of error we'll just retry the run
 */
func runGoList(path string) ([]byte, error) <span class="cov0" title="0">{
        out, err := runCmd(path, "")
        if err != nil </span><span class="cov0" title="0">{
                // rerun with -mod=vendor
                vendorDir := filepath.Join(filepath.Dir(path), "vendor")
                _, err := os.Stat(vendorDir)
                if err == nil </span><span class="cov0" title="0">{
                        if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                log.Debug("Retrying `go list` with `-mod=vendor` flag")
                                out, err = runCmd(path, "-mod=vendor")
                        }</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Debug("Retrying `go list` with `-mod=readonly` flag")
                        out, err = runCmd(path, "-mod=readonly")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Debug("Retrying `go list` with `-e` flag")
                        out, err = runCmd(path, "-e")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("All `go list` attempts failed")

                        }</span>
                }
        }

        <span class="cov0" title="0">return out, nil</span>
}

// GetGolangDeps uses `go list` gather a list of dependencies located at `path`
// returning an array of `GoPkg` structs
func GetGolangDeps(path string) (map[string]GoPkg, error) <span class="cov0" title="0">{
        log.Debugf("GetGolangDeps %s", path)
        // need to use a map as we'll get lots of duplicate entries
        gathered := make(map[string]GoPkg)

        out, err := runGoList(path)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        /* we cann't just marshall the json as go list returns multiple json
         * documents not an array of json - which is annoying
         */
        <span class="cov0" title="0">decoder := json.NewDecoder(strings.NewReader(string(out)))

        for </span><span class="cov0" title="0">{
                var goListDeps GoListDeps
                err := decoder.Decode(&amp;goListDeps)
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">importPath := goListDeps.ImportPath

                if _, ok := gathered[importPath]; ok </span><span class="cov0" title="0">{
                        if gathered[importPath].Version != semver.Max(gathered[importPath].Version, getVersion(goListDeps)) </span><span class="cov0" title="0">{
                                gathered[importPath] = GoPkg{
                                        Version: getVersion(goListDeps),
                                        Gofiles: goListDeps.GoFiles,
                                }
                        }</span>
                } else<span class="cov0" title="0"> {
                        gathered[importPath] = GoPkg{
                                Version: getVersion(goListDeps),
                                Gofiles: goListDeps.GoFiles,
                        }
                }</span>
        }
        <span class="cov0" title="0">return gathered, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package scan

import (
        "path/filepath"

        "github.com/BurntSushi/toml"
        log "github.com/sirupsen/logrus"
)

type GoPkgLockDeps struct {
        Name    string
        Version string
}

type goPkg struct {
        Name     string   `toml:"name"`
        Packages []string `toml:"packages"`
        Revision string   `toml:"revision"`
        Version  string   `toml:"version"`
}

type goPkgDeps struct {
        Deps []goPkg `toml:"projects"`
}

func GetGoPkgDeps(path string) ([]GoPkgLockDeps, error) <span class="cov0" title="0">{
        log.Debugf("GetGoPkgDeps %s", path)

        var deps goPkgDeps
        var gathered []GoPkgLockDeps

        _, err := toml.DecodeFile(path, &amp;deps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, d := range deps.Deps </span><span class="cov0" title="0">{
                ver := d.Version
                if ver == "" </span><span class="cov0" title="0">{
                        ver = d.Revision
                }</span>

                <span class="cov0" title="0">gathered = append(gathered,
                        GoPkgLockDeps{
                                Name:    d.Name,
                                Version: ver,
                        },
                )

                for _, subpackage := range d.Packages </span><span class="cov0" title="0">{
                        if subpackage != "." </span><span class="cov0" title="0">{
                                gathered = append(gathered,
                                        GoPkgLockDeps{
                                                Name:    filepath.Join(d.Name, subpackage),
                                                Version: ver,
                                        },
                                )
                        }</span>
                }
        }

        <span class="cov0" title="0">return gathered, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package scan

import (
        "strings"

        "github.com/mcoops/jargo"
        log "github.com/sirupsen/logrus"
)

// GetJarDeps uses github.com/mcoops/jargo retrieve the java dependencies
func GetJarDeps(path string) (map[string]string, error) <span class="cov0" title="0">{
        log.Debugf("GetJarDeps %s", path)
        gathered := make(map[string]string)

        jar, err := jargo.GetJarInfo(path)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, j := range jar.Files </span><span class="cov0" title="0">{
                idx := strings.LastIndex(j, "@")

                if idx == -1 || idx+1 &gt; len(j) </span><span class="cov0" title="0">{
                        gathered[j] = ""
                }</span> else<span class="cov0" title="0"> {
                        gathered[j[:idx]] = j[idx+1:]
                }</span>
        }
        <span class="cov0" title="0">return gathered, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package scan

import (
        "context"
        "path/filepath"
        "slices"

        scalibr "github.com/google/osv-scalibr"
        "github.com/google/osv-scalibr/extractor"
        "github.com/google/osv-scalibr/extractor/filesystem/language/java/javalockfile"
        el "github.com/google/osv-scalibr/extractor/filesystem/list"
        scalibrfs "github.com/google/osv-scalibr/fs"
        scalog "github.com/google/osv-scalibr/log"
        log "github.com/sirupsen/logrus"
)

func isTestDep(i *extractor.Inventory) bool <span class="cov0" title="0">{
        if metadata, ok := i.Metadata.(*javalockfile.Metadata); ok </span><span class="cov0" title="0">{
                if slices.Contains(metadata.DepGroups(), "test") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func GetMvnDeps(path string) (map[string]string, error) <span class="cov0" title="0">{
        log.Debugf("GetMvnDeps %s", path)
        scalog.SetLogger(log.StandardLogger())
        dir := filepath.Dir(path)
        sc := &amp;scalibr.ScanConfig{
                ScanRoots:             scalibrfs.RealFSScanRoots(dir),
                FilesystemExtractors:  el.Java,
                PrintDurationAnalysis: false,
        }

        gathered := make(map[string]string, 0)
        results := scalibr.New().Scan(context.Background(), sc)
        for _, i := range results.Inventories </span><span class="cov0" title="0">{
                if isTestDep(i) </span><span class="cov0" title="0">{
                        log.Debugf("skipping test dependency %s@%s", i.Name, i.Version)
                        continue</span>
                }

                <span class="cov0" title="0">gathered[i.Name] = i.Version</span>
        }

        <span class="cov0" title="0">return gathered, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package scan

import (
        "encoding/json"
        "fmt"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/RedHatProductSecurity/deplist/internal/utils"
        log "github.com/sirupsen/logrus"
)

type yarnDependencies []yarnDependency

type yarnDependency struct {
        Name     string           `json:"name"`
        Children yarnDependencies `json:"children"`
}

type yarnOutput struct {
        Type string `json:"type"`
        Data struct {
                Deps yarnDependencies `json:"trees"`
        }
}

type npmDependency struct {
        Version      string                   `json:"version"`
        Dependencies map[string]npmDependency `json:"dependencies"`
}

type npmListOutput struct {
        Dependencies map[string]npmDependency `json:"dependencies"`
}

// NodeJSGather dependencies found, name and version
type NodeJSGather struct {
        Name    string
        Version string
}

// TODO: remove this global
var gatheredNode map[string]NodeJSGather

func recordPackage(packageName, version string) <span class="cov0" title="0">{
        // opposite now, we don't care if its specifying version ranges like 5.x.x,
        // or 5.* etc. Just get the versions.
        if len(version) &gt; 0 </span><span class="cov0" title="0">{
                // skip if it's specifying the major
                // i.e. d3-path@2 only care about d3-path@2.0.0
                if len(version) == 1 </span><span class="cov0" title="0">{
                        return
                }</span>

                // if not digit, then range
                <span class="cov0" title="0">if !utils.CharIsDigit(version) </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if version[len(version)-1] == 'x' </span><span class="cov0" title="0">{
                        return
                }</span>

                // still a version range
                <span class="cov0" title="0">if strings.Contains(version, " - ") || strings.Contains(version, "||") </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">if _, ok := gatheredNode[packageName+version]; !ok </span><span class="cov0" title="0">{
                gatheredNode[packageName+version] = NodeJSGather{
                        Name:    packageName,
                        Version: version,
                }
        }</span>
}

func gatherYarnNode(dep yarnDependency) <span class="cov0" title="0">{
        // incase package starts with @
        splitIdx := strings.LastIndex(dep.Name, "@")

        var name string
        var version string

        if splitIdx != -1 </span><span class="cov0" title="0">{
                name = dep.Name[:splitIdx]
                version = dep.Name[splitIdx+1:]
        }</span> else<span class="cov0" title="0"> {
                name = dep.Name
                version = ""
        }</span>

        <span class="cov0" title="0">recordPackage(name, version)

        if len(dep.Children) &gt; 0 </span><span class="cov0" title="0">{
                for _, child := range dep.Children </span><span class="cov0" title="0">{
                        gatherYarnNode(child)
                }</span>
        }
}

func gatherNPMNode(name string, dependency npmDependency) <span class="cov0" title="0">{
        recordPackage(name, dependency.Version)
        for childName, childDep := range dependency.Dependencies </span><span class="cov0" title="0">{
                gatherNPMNode(childName, childDep)
        }</span>
}

// GetNodeJSDeps scans the path for either `yarn.lock` or `package-lock.json`,
// then use the appropriate pkg managers to produce depencies lists of type
// `NodeJSGather`
func GetNodeJSDeps(path string) (map[string]NodeJSGather, error) <span class="cov0" title="0">{
        log.Debugf("GetNodeJSDeps %s", path)
        switch filepath.Base(path) </span>{
        case "yarn.lock":<span class="cov0" title="0">
                return getYarnDeps(path)</span>
        case "package-lock.json":<span class="cov0" title="0">
                return getNPMDeps(path)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown NodeJS dependency file %q", path)</span>
}

func getYarnDeps(path string) (map[string]NodeJSGather, error) <span class="cov0" title="0">{
        var yarnOutput yarnOutput
        gatheredNode = make(map[string]NodeJSGather)

        dirPath := filepath.Dir(path)

        data, err := exec.Command("yarn", "--cwd", dirPath, "list", "--prod", "--json", "--no-progress").Output()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;yarnOutput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, deps := range yarnOutput.Data.Deps </span><span class="cov0" title="0">{
                gatherYarnNode(deps)
        }</span>

        <span class="cov0" title="0">return gatheredNode, nil</span>
}

func getNPMDeps(path string) (map[string]NodeJSGather, error) <span class="cov0" title="0">{
        var npmOutput npmListOutput
        gatheredNode = make(map[string]NodeJSGather)

        cmd := exec.Command("npm", "list", "--prod", "--json", "--depth=99")
        cmd.Dir = filepath.Dir(path)

        data, err := cmd.Output()

        // npm has a nasty habbit of not returning cleanly so if there is data
        // just attempt to unmarshal
        if data == nil &amp;&amp; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;npmOutput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for depName, dep := range npmOutput.Dependencies </span><span class="cov0" title="0">{
                gatherNPMNode(depName, dep)
        }</span>

        <span class="cov0" title="0">return gatheredNode, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package scan

import (
        "bufio"
        "os"
        "regexp"
        "strings"

        log "github.com/sirupsen/logrus"
)

// Account for &gt;, &lt;, &gt;=, &lt;=, ==, !=, ~= and *
var /* const */ re = regexp.MustCompile(`[&lt;&gt;!~*]+`)

// GetPythonDeps scans path for python deps using the `requirements.txt` file
func GetPythonDeps(path string) (map[string]string, error) <span class="cov0" title="0">{
        log.Debugf("GetPythonDeps %s", path)
        gathered := make(map[string]string)

        file, err := os.Open(path)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()

                // skip comments
                // and editable? https://github.com/pypa/pip/issues/4812
                if strings.HasPrefix(line, "#") || strings.HasPrefix(line, "-e") || line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // trim off suffixes like below
                // suds-py3;python_version&gt;="3.0"
                // suds;python_version&lt;"3.0"
                <span class="cov0" title="0">line = strings.Split(line, ";")[0]

                // easy case, elasticsearch-curator==5.8.1
                // record name and version, only for ==
                idx := strings.Index(line, "==")
                if idx &gt; 0 </span><span class="cov0" title="0">{
                        // test if there's a ';', i.e. unittest2==0.5.1; python_version == '2.6'
                        colIdx := strings.Index(line, ";")
                        if colIdx &gt; 0 </span><span class="cov0" title="0">{
                                if idx+2 &gt;= colIdx </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                // truncate line
                                <span class="cov0" title="0">line = line[:colIdx]</span>
                        }
                        <span class="cov0" title="0">gathered[line[:idx]] = line[idx+2:]
                        continue</span>
                }

                // every other permutation just use the name as we can't guarantee
                // the version, just grab the name using first occurrence
                <span class="cov0" title="0">match := re.FindStringIndex(line)

                if match != nil </span><span class="cov0" title="0">{
                        // save substr before special chars
                        gathered[line[:match[0]]] = ""
                }</span> else<span class="cov0" title="0"> {
                        // save entire substr
                        gathered[line] = ""
                }</span>
        }

        <span class="cov0" title="0">return gathered, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package scan

import (
        "context"
        _ "embed"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

//go:embed gemfile-parser.rb
var gemfileScriptData []byte

//go:embed gemspec-parser.rb
var gemSpecScriptData []byte

type Script struct {
        Name string
        Data []byte
}

var gemFileParser = Script{
        Name: "gemfile-parser.rb",
        Data: gemfileScriptData,
}

var gemSpecParser = Script{
        Name: "gemspec-parser.rb",
        Data: gemSpecScriptData,
}

func GetRubyDeps(path string) (map[string]string, error) <span class="cov8" title="1">{
        log.Debugf("GetRubyDeps %s", path)
        baseDir := filepath.Dir(path)
        entries, err := os.ReadDir(baseDir)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">var gemspec string
        for _, e := range entries </span><span class="cov8" title="1">{
                filename := e.Name()
                if strings.HasSuffix(filename, ".gemspec") </span><span class="cov0" title="0">{
                        gemspec = filepath.Join(baseDir, filename)
                        break</span>
                }
        }

        <span class="cov8" title="1">if gemspec != "" </span><span class="cov0" title="0">{
                log.Debugf("Found %s, parsing", gemspec)
                return runRubyParser(gemSpecParser, gemspec, baseDir)
        }</span>

        <span class="cov8" title="1">lockPath := filepath.Join(baseDir, "Gemfile.lock")

        if _, err := os.Stat(lockPath); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        log.Debugf("Creating %s with `bundle lock`", lockPath)
                        // Create Gemfile.lock
                        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(300)*time.Second)
                        defer cancel()
                        cmd := exec.CommandContext(ctx, "env", fmt.Sprintf("--chdir=%s", baseDir), "bundle", "lock")
                        data, err := cmd.CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debugf("couldn't create %s: %v", lockPath, err)
                                log.Debugf("bundle lock output: %v", string(data))
                        }</span>
                        <span class="cov0" title="0">log.Debugf("Created %s", lockPath)</span>
                } else<span class="cov0" title="0"> {
                        log.Errorf("Unexpected error: %v", err)
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return runRubyParser(gemFileParser, ".", baseDir)</span>
}

func runRubyParser(script Script, arg string, dir string) (map[string]string, error) <span class="cov8" title="1">{
        gathered := make(map[string]string)

        g, err := os.CreateTemp("", script.Name)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Could not create ruby script %s: %s", script.Name, err)
                return gathered, err
        }</span>
        <span class="cov8" title="1">defer os.Remove(g.Name())
        err = os.WriteFile(g.Name(), script.Data, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Could not write ruby script to %s: %s", g.Name(), err)
                return gathered, err
        }</span>

        <span class="cov8" title="1">args := []string{fmt.Sprintf("--chdir=%s", dir), "ruby", g.Name(), arg}
        log.Debugf("Running env %v", args)
        cmd := exec.Command("env", args...)
        data, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error running %s: %v: %s", script.Name, err, string(data))
                return gathered, err
        }</span>

        <span class="cov8" title="1">splitOutput := strings.Split(string(data), "\n")

        for _, line := range splitOutput </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">dep := strings.Split(line, " ")
                if len(dep) == 1 &amp;&amp; dep[0] != "" </span><span class="cov0" title="0">{
                        // no version found for this dep
                        dep = append(dep, "")
                }</span> else<span class="cov8" title="1"> if len(dep) &lt; 2 </span><span class="cov0" title="0">{
                        log.Debugf("Unexpected dependency: %v, skipping", dep)
                        continue</span>
                }
                <span class="cov8" title="1">gathered[dep[0]] = dep[1]</span>
        }

        <span class="cov8" title="1">return gathered, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package scan

import (
        "github.com/BurntSushi/toml"
        log "github.com/sirupsen/logrus"
)

type cargoLockPackage struct {
        Name    string `toml:"name"`
        Version string `toml:"version"`
}

type cargoLockFile struct {
        Version  int                `toml:"version"`
        Packages []cargoLockPackage `toml:"package"`
}

func GetCrates(cargoLockPath string) (map[string]string, error) <span class="cov0" title="0">{
        log.Debugf("GetCrates %s", cargoLockPath)
        gathered := make(map[string]string)

        var cargoLock cargoLockFile
        _, err := toml.DecodeFile(cargoLockPath, &amp;cargoLock)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to parse %s", cargoLockPath)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, lockPackage := range cargoLock.Packages </span><span class="cov0" title="0">{
                gathered[lockPackage.Name] = lockPackage.Version
        }</span>

        <span class="cov0" title="0">return gathered, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package utils

import (
        "archive/zip"
        "path/filepath"
)

func CharIsDigit(c string) bool <span class="cov8" title="1">{
        if len(c) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if c[0] &lt; '0' || c[0] &gt; '9' </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Quickly scan for java files within the zip file
func ZipContainsJava(path string) (bool, error) <span class="cov0" title="0">{
        read, err := zip.OpenReader(path)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer read.Close()

        for _, f := range read.File </span><span class="cov0" title="0">{
                switch filepath.Ext(f.Name) </span>{
                case ".java":<span class="cov0" title="0">
                        fallthrough</span>
                case ".war":<span class="cov0" title="0">
                        fallthrough</span>
                case ".ear":<span class="cov0" title="0">
                        fallthrough</span>
                case ".jar":<span class="cov0" title="0">
                        return true, nil</span>
                }
        }

        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
